<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Redux - 简约的魅力</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
            <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Redux - 简约的魅力</h1>
                    <h3>react应用架构内部培训</h3>
                    <p>
                    <small>Created by <a href="https://github.com/MofeLee">李勇</a></small>
                    </p>
                    <aside class="notes" data-markdown>
                        欢迎观看系列教程 redux - 简约的魅力

                        非常激动终于开始讲redux了

                        学完react,似乎依旧看不出来react究竟强大在哪

                        react不像angular那样复杂

                        它只专注于表现层

                        想要发挥出react最强大的能量

                        最终还需要一个完善的前端应用架构来支撑

                        因此facebook提出了一个叫做flux的应用架构

                    </aside>
                </section>

                <section>
                    <section>
                        <h2>前端应用面临的问题</h2>

                        <aside class="notes" data-markdown="">
                            在谈论应用框架之前

                            我想先谈谈前端应用面临的问题

                            当我们的应用变得越来越复杂的时候

                            我们需要管理比以前复杂多的状态

                        </aside>
                    </section>

                    <section>
                        <h2>日益复杂的应用状态</h2>

                        <aside class="notes" data-markdown="">
                            （展示facebook和weibo的组件）

                            这些状态包括服务器响应，缓存数据等

                            事实上，UI的状态也非常复杂

                            管理永远在改变的状态是一件非常困难的事情

                            并且当组件之间发生相互作用的时候

                            再要修改其中一个组件

                            难度系数将会以指数级增长
                        </aside>
                    </section>

                    <section>

                        <h2>MVC的问题</h2>

                        <img src="/img/mvc.png" class="fragment">

                        <aside class="notes" data-markdown="">
                            事实上，在flux出来之前

                            已经有很多公司在管理应用状态做出了很多努力

                            但大部分框架都使用类似MVC的方式来控制应用状态

                            事实上，在某些复杂的页面

                            MVC工作的也很不错

                            但当页面之间的组件相互作用越来越强的时候

                            应用模型会变成这个样子

                            (展示图片)

                            模型和视图之间像一张网一样交织着

                            我们不得不声明很多全局变量来完成一些页面的交互

                            在学习程序语言的过程中，我们知道，全局变量是魔鬼

                            它会使我们的应用发生一些不可预测的事情

                        </aside>
                    </section>

                    <section>
                        <h2>Flux是如何解决这个问题的</h2>

                        <img src="/img/flux2.png" class="fragment">

                        <aside class="notes" data-markdown="">
                            为了防止前端复杂页面变的不可预测

                            facebook提出了flux应用架构

                            (展示图片)

                            在flux应用架构中

                            应用状态保存在store中

                            store与model最主要的区别就是store是一个只读对象

                            我们只能通过dispatch一个action

                            也就是调度一个动作来改变store

                            这是我们的数据流动始终是单向的

                            我们给每次改变都起了一个名字，叫做action

                            所以每次改变应用的store都是可追溯的

                            我们终于可以预测我们的应用是如何改变的了！！

                        </aside>
                    </section>

                    <section>
                        <h2>理解flux</h2>

                        <img src="/img/flux1.png" alt="">

                        <aside class="notes" data-markdown="">
                            事实上，我们可以把像这样的数据流

                            理解为向河里丢石子

                            action是我们的石头

                            dispatch是手

                            当我们需要改变平静的湖面时

                            只需要把这个action dispatch到湖里就行

                            注意，这里的湖指的不是view层

                            得益于react,我们能更优雅的通过store来控制view层

                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Redux</h1>

                        <aside class="notes" data-markdown="">
                            事实上，flux只是一个软件架构的思想

                            在实际应用中，我们需要自己实现其中的细节

                            其中，我认为最优雅的实现就是redux
                        </aside>
                    </section>

                    <section>
                        <h2>为什么使用redux</h2>

                        <img class="fragment" src="/img/plot.png" alt="">

                        <aside class="notes" data-markdown="">
                            事实上，传统的项目的开发过程中

                            如果组件之间的关联性越来越强烈时

                            我们的应用复杂程序会呈指数型增长

                            我们需要一种可以像docker swarm

                            或者像google的mapreduce一样

                            弹性并且无痛的增长我们的应用

                            这里简单的提下

                            docker swarm是一种新型的web部署方式

                            基于云运算

                            我们可以在运行高峰时在数分钟内运行起成白上千台应用服务器

                            需要做的只是用docker启动服务

                            它提供一种自动发现网内，并自动配置的机制

                            在讨论redux如何实现这个之前

                            我想先谈谈科赫曲线
                        </aside>
                    </section>

                    <section data-background="/img/snowflakes.jpg">
                        <h1 style="color: white; background-color: rgba(0,0,0,.6)">科赫曲线</h1>

                        <img class="fragment" src="/img/kochCurves.jpg" alt="" style="background-color:white;">

                        <aside class="notes" data-markdown="">
                            科赫曲线也叫做雪花曲线

                            （展示图片）

                            因为形状很像雪花

                            乍一看好像很复杂

                            仔细看这张图

                            你会发现其实这是一张很有趣的图片

                            当我们把这张图分成数个小块时

                            每个小块都是整体缩小后的形状

                        </aside>
                    </section>

                    <section>
                        <h2>分解科赫曲线图</h2>

                        <img src="/img/koch2.png" alt="">

                        <aside class="notes" data-markdown="">
                            
                        </aside>
                    </section>
                </section>

                <section>
                    <h2>Hello There</h2>
                    <p>
                    reveal.js enables you to create beautiful interactive slide decks using HTML. This presentation will show you examples of what it can do.
                    </p>
                </section>

                 <section style="text-align: left;">
                    <h1>THE END</h1>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,

    transition: 'slide', // none/fade/slide/convex/concave/zoom

    // Optional reveal.js plugins
    dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true },
    { src: 'plugin/notes/notes.js', async: true }
    ]
});

        </script>

        <script src="//cdn.bootcss.com/jquery/2.2.0/jquery.min.js"></script>

    </body>
</html>
